<script>
  // Set your live server URL here, or leave empty for same-origin (local dev)
  const SERVER_URL = "https://b-twap.onrender.com"; // <- UPDATE this
  const FEED_URL = SERVER_URL + "/latest.json";
  const OHLC_URL = SERVER_URL + "/ohlc";

  const updateInterval = 1000;
  const MAX_CANDLES = 1000;
  const FX_LIST = ["BRL", "RUB", "INR", "CNY", "ZAR"];

  // Chart setup (unchanged)
  const chartContainer = document.getElementById("chart");
  const chart = LightweightCharts.createChart(chartContainer, {
    layout: { backgroundColor: "#0b0f14", textColor: "#eaeaea" },
    grid: { vertLines: { color: "#333" }, horzLines: { color: "#333" } },
    rightPriceScale: { borderColor: "#555", autoScale: true },
    timeScale: { borderColor: "#555", timeVisible: true, secondsVisible: true }
  });
  const candleSeries = chart.addCandlestickSeries({
    upColor: "#ffd700", downColor: "#ff4b4b", borderVisible: false, wickColor: "#eee"
  });

  // FX display
  const fxContainer = document.getElementById("fxContainer");
  FX_LIST.forEach(ccy => {
    const div = document.createElement("div");
    div.className = "fx-row";
    div.id = "fx_" + ccy;
    div.innerHTML = `<span>${ccy}</span> : <span>…</span> units/USD`;
    fxContainer.appendChild(div);
  });

  let timeframeMin = parseInt(document.getElementById("timeframe").value);
  let candles = [];
  let currentCandle = null;

  function getCandleTime(ts, tfMin) {
    return Math.floor(ts / (tfMin * 60));
  }

  // Load historical candles from server
  async function loadHistoricalCandles() {
    try {
      const res = await fetch(`${OHLC_URL}?timeframe=${timeframeMin}&limit=${MAX_CANDLES}`);
      const data = await res.json();

      candles = data.map(c => ({
        time: Math.floor(c.time),
        open: c.open,
        high: c.high,
        low: c.low,
        close: c.close
      }));

      currentCandle = candles.length ? { ...candles[candles.length - 1] } : null;
      candleSeries.setData(candles);
    } catch (e) {
      console.error("Failed to load historical candles", e);
    }
  }

  // Fetch latest TWAP & update chart
  async function updateTWAP() {
    try {
      const res = await fetch(FEED_URL);
      const d = await res.json();
      const tsUnix = Math.floor(new Date(d.timestamp_utc).getTime() / 1000);

      // Display values
      document.getElementById("unitUsd").innerText = d.unit_usd.toFixed(2);
      document.getElementById("unitGold").innerText = d.unit_gold_grams.toFixed(6);
      document.getElementById("hundredUsd").innerText = (d.unit_usd*100).toFixed(2);
      document.getElementById("goldTwap").innerText = d.gold_usd_per_oz_twap.toFixed(2);
      document.getElementById("timestamp").innerText = d.timestamp_utc.replace("T", " ").replace("Z", " UTC");

      // FX
      if (d.fx_usd_twap) {
        FX_LIST.forEach(ccy => {
          const div = document.getElementById("fx_" + ccy);
          // d.fx_usd_twap[ccy] = USD per 1 unit of ccy → we want units per USD
          const unitsPerUSD = 1 / d.fx_usd_twap[ccy];
          div.querySelector("span:last-child").innerText = unitsPerUSD.toFixed(2);
        });
      }

      // Candles
      const candleTime = getCandleTime(tsUnix, timeframeMin);
      if (!currentCandle || currentCandle.time !== candleTime) {
        if (currentCandle) candles.push(currentCandle);

        currentCandle = { time: candleTime, open: d.unit_usd, high: d.unit_usd, low: d.unit_usd, close: d.unit_usd };
        if (candles.length > MAX_CANDLES) candles = candles.slice(-MAX_CANDLES);
        candleSeries.setData(candles.concat([currentCandle]));
      } else {
        currentCandle.high = Math.max(currentCandle.high, d.unit_usd);
        currentCandle.low = Math.min(currentCandle.low, d.unit_usd);
        currentCandle.close = d.unit_usd;
        candleSeries.update(currentCandle);
      }

    } catch (e) {
      console.error("Feed fetch error", e);
    }
  }

  async function init() {
    await loadHistoricalCandles();
    await updateTWAP();
    setInterval(updateTWAP, updateInterval);
  }

  init();

  document.getElementById("timeframe").addEventListener("change", () => {
    timeframeMin = parseInt(document.getElementById("timeframe").value);
    init();
  });
</script>
